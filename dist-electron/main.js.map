{"version":3,"file":"main.js","sources":["../src/main/main.ts"],"sourcesContent":["const {\n  app,\n  BrowserWindow,\n  systemPreferences,\n  ipcMain,\n  dialog,\n} = require(\"electron\");\nconst path = require(\"path\");\nconst isDev = require(\"electron-is-dev\");\nconst { SystemAudioCapture } = require(\"bindings\")(\"systemAudio\");\n\ninterface AudioCaptureOptions {\n  sessionId: number;\n  system: boolean;\n  mic: boolean;\n}\n\nlet audioCapture: any = null;\nlet isCleaningUp = false; // Add cleanup lock\n\nfunction createWindow() {\n  const mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      nodeIntegration: false,\n      contextIsolation: true,\n      preload: path.join(__dirname, \"preload/index.js\"),\n    },\n  });\n\n  // Load the app\n  if (isDev) {\n    mainWindow.loadURL(\"http://localhost:5173\");\n  } else {\n    mainWindow.loadFile(path.join(__dirname, \"../../dist/index.html\"));\n  }\n\n  // Request permissions when needed\n  const requestPermissions = async () => {\n    try {\n      // Request screen capture permission\n      const screenCaptureStatus = await systemPreferences.getMediaAccessStatus(\n        \"screen\"\n      );\n      if (screenCaptureStatus !== \"granted\") {\n        const result = await dialog.showMessageBox({\n          type: \"warning\",\n          buttons: [\"Open System Preferences\", \"Cancel\"],\n          defaultId: 0,\n          message: \"Screen Recording Permission Required\",\n          detail:\n            \"This app needs screen recording permission to capture system audio. Please enable it in System Preferences > Security & Privacy > Privacy > Screen Recording.\",\n        });\n\n        if (result.response === 0) {\n          await systemPreferences.askForMediaAccess(\"screen\");\n        } else {\n          throw new Error(\"Screen recording permission denied\");\n        }\n      }\n\n      // Request microphone permission (needed for some audio capture scenarios)\n      const micStatus = await systemPreferences.getMediaAccessStatus(\n        \"microphone\"\n      );\n      if (micStatus !== \"granted\") {\n        await systemPreferences.askForMediaAccess(\"microphone\");\n      }\n    } catch (error) {\n      console.error(\"Error requesting permissions:\", error);\n      throw error;\n    }\n  };\n\n  // Initialize audio capture\n  const initAudioCapture = () => {\n    try {\n      // Force new instance every time\n      audioCapture = new SystemAudioCapture();\n      console.log(\"New native module instance created\");\n    } catch (error) {\n      console.error(\"Failed to load native module:\", error);\n      throw error;\n    }\n  };\n\n  // Handle IPC messages\n  ipcMain.handle(\"stop-audio-capture\", async () => {\n    try {\n      await stopExistingCapture();\n    } catch (error) {\n      console.error(\"Error stopping audio capture:\", error);\n      throw error;\n    }\n  });\n\n  const stopExistingCapture = async () => {\n    if (!audioCapture || isCleaningUp) {\n      return; // Skip if already cleaned up or cleaning up\n    }\n\n    isCleaningUp = true;\n    console.log(\"Stopping previous capture instance\");\n\n    try {\n      // Add timeout to prevent hanging\n      await Promise.race([\n        audioCapture.stopCapture(),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error(\"Stop capture timeout\")), 1000)\n        ),\n      ]);\n\n      // Add cooldown to ensure native resources release\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Force cleanup of old instance\n      audioCapture = null;\n\n      console.log(\"Capture instance cleanup completed\");\n    } catch (error) {\n      console.error(\"Error stopping capture:\", error);\n      // Ensure cleanup even on error\n      audioCapture = null;\n    } finally {\n      isCleaningUp = false;\n    }\n  };\n\n  ipcMain.handle(\n    \"start-audio-capture\",\n    async (event, options: AudioCaptureOptions) => {\n      try {\n        console.log(\"Starting new audio capture with options:\", options);\n        await requestPermissions();\n\n        // Initialize new capture instance without stopping (we already stopped)\n        initAudioCapture();\n\n        // Start capture with the callback\n        audioCapture.startCapture((buffer: Buffer, format: any) => {\n          if (!mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\"audio-data\", {\n              buffer,\n              format,\n              sessionId: options.sessionId,\n            });\n          }\n        });\n\n        console.log(\"Audio capture started successfully\");\n      } catch (error) {\n        console.error(\"Error starting audio capture:\", error);\n        // Ensure cleanup on error\n        await stopExistingCapture();\n        throw error;\n      }\n    }\n  );\n\n  // Clean up on window close\n  mainWindow.on(\"closed\", async () => {\n    try {\n      console.log(\"Window closing, cleaning up audio capture\");\n      await stopExistingCapture();\n    } catch (error) {\n      console.error(\"Error cleaning up audio capture:\", error);\n    }\n  });\n}\n\napp.whenReady().then(() => {\n  createWindow();\n\n  app.on(\"activate\", () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\n\napp.on(\"window-all-closed\", () => {\n  if (process.platform !== \"darwin\") {\n    app.quit();\n  }\n});\n"],"names":[],"mappings":"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"}